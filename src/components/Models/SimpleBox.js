/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { forwardRef, useRef, useEffect, useContext, useState } from "react";
import {useThree, instancedMesh } from "@react-three/fiber";
import * as THREE from "three";
import { useGesture } from "@use-gesture/react";
import { Cone } from "@react-three/drei";
import { TextContext } from "../Helpers/SceneWrapper";
const tempObject = new THREE.Object3D();
//Know the problem isn't the BoxContent, or the way they are imported. Makes it very strange where this issue is coming from
/*
When dragging one after dragging another one, its like it thinks im still dragging the previous ones
The stop drag is being called. 

*/
export const SimpleGeometry = forwardRef((props, forwarded) => {

  const { size, viewport } = useThree();
  const aspect = size.width / viewport.width;
  var count = props.colliders.length;
  let [currentPosx, currentPosy] = [0, 0];
  const mesh = useRef();

  const tcontext = useContext(TextContext)
  const handleDisableText = () => {
    tcontext.setText({enable: false, ...tcontext.content, ...tcontext.title})
}

  let dragged = false;
  const handleChange = () => {
    props.setDrag(dragged);
}
  useEffect(() => { 
    let i = 0;
    for (let x = 0; x < count; x++) {
      const id = i++;
      
  
      tempObject.scale.set(
        props.colliders[x].args[0],
        props.colliders[x].args[1],
        props.colliders[x].args[2]
      );
      tempObject.position.set(
        props.colliders[x].position[0],
        props.colliders[x].position[1],
        props.colliders[x].position[2]
      );
      tempObject.updateMatrix();

      forwarded.current.setMatrixAt(id, tempObject.matrix);

      forwarded.current.instanceMatrix.needsUpdate = true;
    }
  });
  const bind = useGesture({
  
    onDrag: ({ movement: [x, y], first: intial}) => {
      tcontext.setText({...tcontext, beingDragged: true})
      dragged= true;
      handleChange()
     
      forwarded.current.position.set(
        ((x - currentPosx) / aspect) * 1.2 + props.lastPos[0],
        ((currentPosy - y) / aspect) * 1.2 + props.lastPos[1],
        0
      );
    
 
    },
    onDragEnd: ({}) => {
      tcontext.setText({...tcontext, beingDragged: false})
      dragged= false;
      console.log("false")
      handleChange()
    }
  });
  

  return (
  
      <instancedMesh
      ref={forwarded}
        {...bind()}
        position={props.positionCol}
        rotation={props.rotationCol}
        setDrag={handleChange}
        args={[null, null, count]}
      >
        <boxBufferGeometry attach="geometry"></boxBufferGeometry>
        <meshStandardMaterial
          transparent={true}
          opacity={0}
          attach="material"
        />
      </instancedMesh>

   
 
  );
});
