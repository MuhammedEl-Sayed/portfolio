/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useEffect, useState, forwardRef, useMemo  } from 'react'
import { useGLTF } from '@react-three/drei'
import {useBox, Debug, useTrimesh, useCompoundBody} from "@react-three/cannon"
import { Canvas, useFrame, useThree, } from "@react-three/fiber";
import { SimpleGeometry } from './Models/SimpleBox';
import {LnIcon} from "./Models/Lnicon"
import model from "../components/Models/linkicon.glb"
import * as THREE from "three";
  

const BasicModel = forwardRef((props, ref) => {
  const { scene } = useGLTF(props.model);



     return (
      <primitive object={scene}/>
    
     )
/*   const { scene } = useGLTF(props.model);
  
  return <primitive object={scene} materials={scene.materials} ref={ref}/> */
});
export const StupidWrapper = forwardRef((props, ref) => {

  return (
    <group>
      {props.children}
    </group>

  
   )

});
export default function GeneralModel(props, children) {
  const group = useRef();


  //const { nodes, materials } = useGLTF(props.model);
  //const obj = new THREE.Mesh(nodes, materials);
  const box = useRef();
  const position = useRef([0, 0, 0]);
  const rot = useRef([0, 0, 0]);
  var boxes = props.boxes;
  const [ref, api] = useCompoundBody(() => ({
    mass: 0,
    position: props.positionOfObj,
    rotation: props.rotationOfObj,
    shapes: boxes,
  }));
  useEffect(() => {
    const unsubscribe = api.position.subscribe((v) => (position.current = v));
    return unsubscribe;
  }, []);
  useEffect(() => {
    const unsubscribe = api.rotation.subscribe((v) => (rot.current = v));
    return unsubscribe;
  }, []);
  const [dragging, setDrag] = useState(false);
  const [lastPos, setLastPos] = useState([0,0])
  
  useFrame(() => {
    
    if (dragging === false) {
      box.current.position.set(
        position.current[0],
        position.current[1],
        position.current[2]
      ); //this isnt the problem
      box.current.rotation.set(rot.current[0], rot.current[1], rot.current[2]); 
      setLastPos([position.current[0], position.current[1]])
      api.wakeUp();
    }  if(dragging === true) {
      
      api.sleep();
      api.position.copy(box.current.position);
      api.rotation.copy(box.current.rotation);

    }
  });
  function handleChange(newValue) {
    setDrag(newValue);
  }

  //Need to abstract the Mesh so I can create one 
  return (
    <>
    <SimpleGeometry
    ref={box}
    colliders={boxes}
    positionCol={props.positionOfObj}
    rotationCol={props.positionOfObj}
    setDrag={handleChange}
    lastPos={lastPos}
  />
  <BasicModel model={props.model}>
  {props.children}
  </BasicModel>


    </>
  )
}

